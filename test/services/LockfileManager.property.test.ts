/**
 * LockfileManager Property-Based Tests
 * 
 * Property-based tests for the LockfileManager service using fast-check.
 * These tests verify correctness properties that should hold for all valid inputs.
 * 
 * Properties covered:
 * - Property 2: Lockfile Schema Validation (Requirements 4.2-4.7, 11.1-11.4, 15.1-15.2)
 * - Property 3: Lockfile Round-Trip Consistency (Requirements 4.1, 5.2, 5.5)
 * - Property 7: Checksum Modification Detection (Requirements 14.1-14.3)
 * - Property 12: Source and Hub Configuration Completeness (Requirements 12.1-12.6)
 * - Property 15: Atomic Lockfile Write (Requirements 15.6)
 */

import * as assert from 'assert';
import * as fc from 'fast-check';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import {
    LockfileBuilder,
    LockfileGenerators,
    createMockLockfile,
    LOCKFILE_DEFAULTS
} from '../helpers/lockfileTestHelpers';
import { PropertyTestConfig } from '../helpers/propertyTestHelpers';
import { Lockfile } from '../../src/types/lockfile';
import { SchemaValidator } from '../../src/services/SchemaValidator';

suite('LockfileManager Property Tests', () => {
    let tempDir: string;
    let schemaValidator: SchemaValidator;
    const lockfileSchemaPath = path.join(process.cwd(), 'schemas', 'lockfile.schema.json');

    // ===== Test Utilities =====
    const createTempDir = (): string => {
        const dir = path.join(__dirname, '..', '..', 'test-temp-lockfile-prop-' + Date.now());
        fs.mkdirSync(dir, { recursive: true });
        return dir;
    };

    const cleanupTempDir = (dir: string): void => {
        if (fs.existsSync(dir)) {
            fs.rmSync(dir, { recursive: true, force: true });
        }
    };

    setup(() => {
        tempDir = createTempDir();
        schemaValidator = new SchemaValidator(process.cwd());
    });

    teardown(() => {
        cleanupTempDir(tempDir);
        schemaValidator.clearCache();
    });

    /**
     * Property 2: Lockfile Schema Validation
     * 
     * For any lockfile generated by the extension, it SHALL be valid JSON with
     * required fields ($schema, version, generatedAt, generatedBy, bundles, sources)
     * and use 2-space indentation.
     * 
     * **Validates: Requirements 4.2-4.7, 11.1-11.4, 15.1-15.2**
     */
    suite('Property 2: Lockfile Schema Validation', () => {
        test('generated lockfiles should be valid against JSON schema', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Validate against JSON schema
                        const result = await schemaValidator.validate(lockfile, lockfileSchemaPath);
                        
                        // Property: All generated lockfiles should be schema-valid
                        assert.strictEqual(
                            result.valid,
                            true,
                            `Schema validation failed: ${result.errors.join(', ')}`
                        );
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('lockfiles should have all required fields', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.lockfile({ minBundles: 0, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Property: All required fields must be present
                        assert.ok(lockfile.$schema, 'Missing $schema field');
                        assert.ok(lockfile.version, 'Missing version field');
                        assert.ok(lockfile.generatedAt, 'Missing generatedAt field');
                        assert.ok(lockfile.generatedBy, 'Missing generatedBy field');
                        assert.ok(lockfile.bundles !== undefined, 'Missing bundles field');
                        assert.ok(lockfile.sources !== undefined, 'Missing sources field');
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('version field should be semver-compatible', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.lockfile(),
                    async (lockfile: Lockfile) => {
                        // Property: Version should match semver pattern
                        const semverPattern = /^\d+\.\d+\.\d+$/;
                        assert.ok(
                            semverPattern.test(lockfile.version),
                            `Version "${lockfile.version}" is not semver-compatible`
                        );
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('generatedAt should be valid ISO timestamp', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.lockfile(),
                    async (lockfile: Lockfile) => {
                        // Property: generatedAt should be parseable as ISO date
                        const date = new Date(lockfile.generatedAt);
                        assert.ok(
                            !isNaN(date.getTime()),
                            `generatedAt "${lockfile.generatedAt}" is not a valid ISO timestamp`
                        );
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('bundle entries should have all required fields', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Property: Each bundle entry must have required fields
                        for (const [bundleId, entry] of Object.entries(lockfile.bundles)) {
                            assert.ok(entry.version, `Bundle ${bundleId} missing version`);
                            assert.ok(entry.sourceId, `Bundle ${bundleId} missing sourceId`);
                            assert.ok(entry.sourceType, `Bundle ${bundleId} missing sourceType`);
                            assert.ok(entry.installedAt, `Bundle ${bundleId} missing installedAt`);
                            assert.ok(entry.commitMode, `Bundle ${bundleId} missing commitMode`);
                            assert.ok(Array.isArray(entry.files), `Bundle ${bundleId} files should be array`);
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('file checksums should be valid SHA256 format', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 2 }),
                    async (lockfile: Lockfile) => {
                        // Property: All file checksums should be 64 hex characters
                        const sha256Pattern = /^[a-f0-9]{64}$/;
                        for (const [bundleId, entry] of Object.entries(lockfile.bundles)) {
                            for (const file of entry.files) {
                                assert.ok(
                                    sha256Pattern.test(file.checksum),
                                    `File ${file.path} in bundle ${bundleId} has invalid checksum format`
                                );
                            }
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });
    });

    /**
     * Property 3: Lockfile Round-Trip Consistency
     * 
     * For any valid lockfile, reading then writing (without modifications)
     * SHALL produce an equivalent lockfile.
     * 
     * **Validates: Requirements 4.1, 5.2, 5.5**
     */
    suite('Property 3: Lockfile Round-Trip Consistency', () => {
        // Helper to normalize lockfile by removing undefined values (JSON doesn't preserve them)
        const normalizeLockfile = (lockfile: Lockfile): Lockfile => {
            return JSON.parse(JSON.stringify(lockfile));
        };

        test('JSON stringify then parse should preserve lockfile structure', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Property: JSON round-trip should preserve structure
                        // Note: undefined values are not preserved in JSON
                        const serialized = JSON.stringify(lockfile, null, 2);
                        const deserialized = JSON.parse(serialized) as Lockfile;
                        const normalized = normalizeLockfile(lockfile);
                        
                        // Deep equality check (comparing normalized versions)
                        assert.deepStrictEqual(
                            deserialized,
                            normalized,
                            'Round-trip should preserve lockfile structure'
                        );
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('file write then read should preserve lockfile content', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 2 }),
                    async (lockfile: Lockfile) => {
                        // Property: File I/O round-trip should preserve content
                        const lockfilePath = path.join(tempDir, `lockfile-${Date.now()}.json`);
                        const normalized = normalizeLockfile(lockfile);
                        
                        // Write to file
                        fs.writeFileSync(lockfilePath, JSON.stringify(lockfile, null, 2));
                        
                        // Read back
                        const content = fs.readFileSync(lockfilePath, 'utf8');
                        const readLockfile = JSON.parse(content) as Lockfile;
                        
                        // Verify equality (comparing normalized versions)
                        assert.deepStrictEqual(
                            readLockfile,
                            normalized,
                            'File round-trip should preserve lockfile content'
                        );
                        
                        // Cleanup
                        fs.unlinkSync(lockfilePath);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });

        test('2-space indentation should be preserved', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 2 }),
                    async (lockfile: Lockfile) => {
                        // Property: 2-space indentation should be used
                        const serialized = JSON.stringify(lockfile, null, 2);
                        
                        // Check for 2-space indentation pattern
                        const lines = serialized.split('\n');
                        const indentedLines = lines.filter(line => line.startsWith('  '));
                        
                        // Should have indented lines if there's content
                        if (Object.keys(lockfile.bundles).length > 0 || Object.keys(lockfile.sources).length > 0) {
                            assert.ok(
                                indentedLines.length > 0,
                                'Should have 2-space indented lines'
                            );
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });
    });

    /**
     * Property 15: Atomic Lockfile Write
     * 
     * For any lockfile update operation, the write SHALL be atomic
     * (using temp file + rename pattern) to prevent corruption during
     * concurrent operations or crashes.
     * 
     * **Validates: Requirements 15.6**
     */
    suite('Property 15: Atomic Lockfile Write', () => {
        // Helper to normalize lockfile by removing undefined values (JSON doesn't preserve them)
        const normalizeLockfile = (lockfile: Lockfile): Lockfile => {
            return JSON.parse(JSON.stringify(lockfile));
        };

        test('atomic write pattern should not corrupt existing lockfile on failure', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 2 }),
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 2 }),
                    async (originalLockfile: Lockfile, newLockfile: Lockfile) => {
                        const lockfilePath = path.join(tempDir, `atomic-test-${Date.now()}.json`);
                        const tempPath = lockfilePath + '.tmp';
                        
                        // Normalize to remove undefined values (JSON doesn't preserve them)
                        const normalizedNew = normalizeLockfile(newLockfile);
                        
                        // Write original lockfile
                        fs.writeFileSync(lockfilePath, JSON.stringify(originalLockfile, null, 2));
                        
                        // Simulate atomic write pattern
                        // 1. Write to temp file
                        fs.writeFileSync(tempPath, JSON.stringify(newLockfile, null, 2));
                        
                        // 2. Rename temp to target (atomic on most filesystems)
                        fs.renameSync(tempPath, lockfilePath);
                        
                        // Property: After atomic write, file should contain new content
                        const content = fs.readFileSync(lockfilePath, 'utf8');
                        const readLockfile = JSON.parse(content) as Lockfile;
                        
                        assert.deepStrictEqual(
                            readLockfile,
                            normalizedNew,
                            'Atomic write should result in new lockfile content'
                        );
                        
                        // Cleanup
                        fs.unlinkSync(lockfilePath);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });

        test('temp file should not exist after successful atomic write', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 2 }),
                    async (lockfile: Lockfile) => {
                        const lockfilePath = path.join(tempDir, `atomic-cleanup-${Date.now()}.json`);
                        const tempPath = lockfilePath + '.tmp';
                        
                        // Simulate atomic write
                        fs.writeFileSync(tempPath, JSON.stringify(lockfile, null, 2));
                        fs.renameSync(tempPath, lockfilePath);
                        
                        // Property: Temp file should not exist after rename
                        assert.strictEqual(
                            fs.existsSync(tempPath),
                            false,
                            'Temp file should not exist after atomic write'
                        );
                        
                        // Cleanup
                        fs.unlinkSync(lockfilePath);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });
    });

    /**
     * Property 7: Checksum Modification Detection
     * 
     * For any installed bundle with recorded checksums, comparing current vs stored
     * checksums SHALL correctly identify modified, missing, and new files.
     * 
     * **Validates: Requirements 14.1-14.3**
     */
    suite('Property 7: Checksum Modification Detection', () => {
        test('identical content should produce identical checksums', async () => {
            await fc.assert(
                fc.asyncProperty(
                    fc.string({ minLength: 1, maxLength: 1000 }),
                    async (content: string) => {
                        // Property: Same content should always produce same checksum
                        const checksum1 = crypto.createHash('sha256').update(content).digest('hex');
                        const checksum2 = crypto.createHash('sha256').update(content).digest('hex');
                        
                        assert.strictEqual(
                            checksum1,
                            checksum2,
                            'Identical content should produce identical checksums'
                        );
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('different content should produce different checksums', async () => {
            await fc.assert(
                fc.asyncProperty(
                    fc.string({ minLength: 1, maxLength: 500 }),
                    fc.string({ minLength: 1, maxLength: 500 }),
                    async (content1: string, content2: string) => {
                        // Skip if contents are identical
                        fc.pre(content1 !== content2);
                        
                        // Property: Different content should produce different checksums
                        const checksum1 = crypto.createHash('sha256').update(content1).digest('hex');
                        const checksum2 = crypto.createHash('sha256').update(content2).digest('hex');
                        
                        assert.notStrictEqual(
                            checksum1,
                            checksum2,
                            'Different content should produce different checksums'
                        );
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('file modification should be detectable via checksum comparison', async () => {
            await fc.assert(
                fc.asyncProperty(
                    fc.string({ minLength: 1, maxLength: 500 }),
                    fc.string({ minLength: 1, maxLength: 500 }),
                    async (originalContent: string, modifiedContent: string) => {
                        // Skip if contents are identical
                        fc.pre(originalContent !== modifiedContent);
                        
                        const filePath = path.join(tempDir, `checksum-test-${Date.now()}.txt`);
                        
                        // Write original content and calculate checksum
                        fs.writeFileSync(filePath, originalContent);
                        const originalChecksum = crypto.createHash('sha256')
                            .update(fs.readFileSync(filePath))
                            .digest('hex');
                        
                        // Modify file
                        fs.writeFileSync(filePath, modifiedContent);
                        const currentChecksum = crypto.createHash('sha256')
                            .update(fs.readFileSync(filePath))
                            .digest('hex');
                        
                        // Property: Modification should be detectable
                        const isModified = originalChecksum !== currentChecksum;
                        assert.strictEqual(
                            isModified,
                            true,
                            'File modification should be detectable via checksum'
                        );
                        
                        // Cleanup
                        fs.unlinkSync(filePath);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });

        test('missing file should be detectable', async () => {
            await fc.assert(
                fc.asyncProperty(
                    fc.string({ minLength: 1, maxLength: 100 }),
                    async (content: string) => {
                        const filePath = path.join(tempDir, `missing-test-${Date.now()}.txt`);
                        
                        // Write file and get checksum
                        fs.writeFileSync(filePath, content);
                        const originalChecksum = crypto.createHash('sha256')
                            .update(fs.readFileSync(filePath))
                            .digest('hex');
                        
                        // Delete file
                        fs.unlinkSync(filePath);
                        
                        // Property: Missing file should be detectable
                        const fileExists = fs.existsSync(filePath);
                        assert.strictEqual(
                            fileExists,
                            false,
                            'Missing file should be detectable'
                        );
                        
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });
    });

    /**
     * Property 12: Source and Hub Configuration Completeness
     * 
     * For any lockfile with bundle entries, corresponding source entries
     * SHALL exist in the sources section.
     * 
     * **Validates: Requirements 12.1-12.6**
     */
    suite('Property 12: Source and Hub Configuration Completeness', () => {
        test('all bundle sourceIds should reference existing sources', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 5 }),
                    async (lockfile: Lockfile) => {
                        // Property: Every bundle's sourceId should exist in sources
                        for (const [bundleId, entry] of Object.entries(lockfile.bundles)) {
                            assert.ok(
                                lockfile.sources[entry.sourceId],
                                `Bundle ${bundleId} references non-existent source ${entry.sourceId}`
                            );
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('source entries should have required type and url fields', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Property: All sources should have type and url
                        for (const [sourceId, source] of Object.entries(lockfile.sources)) {
                            assert.ok(
                                source.type,
                                `Source ${sourceId} missing type field`
                            );
                            assert.ok(
                                source.url,
                                `Source ${sourceId} missing url field`
                            );
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('hub entries should have required name and url fields', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.lockfile({ minBundles: 1, maxBundles: 2, includeHubs: true }),
                    async (lockfile: Lockfile) => {
                        // Property: All hubs should have name and url
                        if (lockfile.hubs) {
                            for (const [hubId, hub] of Object.entries(lockfile.hubs)) {
                                assert.ok(
                                    hub.name,
                                    `Hub ${hubId} missing name field`
                                );
                                assert.ok(
                                    hub.url,
                                    `Hub ${hubId} missing url field`
                                );
                            }
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('profile entries should have required name and bundleIds fields', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.lockfile({ minBundles: 1, maxBundles: 2, includeProfiles: true }),
                    async (lockfile: Lockfile) => {
                        // Property: All profiles should have name and bundleIds
                        if (lockfile.profiles) {
                            for (const [profileId, profile] of Object.entries(lockfile.profiles)) {
                                assert.ok(
                                    profile.name,
                                    `Profile ${profileId} missing name field`
                                );
                                assert.ok(
                                    Array.isArray(profile.bundleIds),
                                    `Profile ${profileId} bundleIds should be array`
                                );
                            }
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('source types should be valid known types', async () => {
            const validSourceTypes = [
                'github', 'gitlab', 'http', 'local',
                'awesome-copilot', 'local-awesome-copilot',
                'apm', 'local-apm', 'olaf', 'local-olaf'
            ];

            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Property: All source types should be valid
                        for (const [sourceId, source] of Object.entries(lockfile.sources)) {
                            assert.ok(
                                validSourceTypes.includes(source.type),
                                `Source ${sourceId} has invalid type: ${source.type}`
                            );
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });
    });
});
